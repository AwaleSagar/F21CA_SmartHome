# import logging
# import random
# from argparse import ArgumentParser
# #import silence_tensorflow
# import os
# from flask import Flask, request
# from flask_restful import Api
# from utils import log
# from utils.abstract_classes import Bot
# from utils.dict_query import DictQuery
# from datetime import datetime
# import random
# import json

# #----------------------------------------------------------------------------
# from ALP import ActionLanguageProcessor
# #----------------------------------------------------------------------------

# app = Flask(__name__)
# api = Api(app)
# BOT_NAME = "EcoBot"
# VERSION = "qq"#log.get_short_git_version()
# BRANCH = "qqq"#log.get_git_branch()

# logger = logging.getLogger(__name__)

# parser = ArgumentParser()
# parser.add_argument('-p', "--port", type=int, default=5130)
# parser.add_argument('-l', '--logfile', type=str, default='logs/' + BOT_NAME + '.log')
# parser.add_argument('-cv', '--console-verbosity', default='info', help='Console logging verbosity')
# parser.add_argument('-fv', '--file-verbosity', default='debug', help='File logging verbosity')

# #-----------------LOAD RASA MODEL----------------------------------------------------------

# #from rasa.nlu.model import Interpreter

# # model path
# #model = "./NLU/models/nlu-20200214-113529/nlu"
# #model = "./NLU/models/Old_NLU/nlu-20200214-113529/nlu"
# #model = "./NLU/models/nlu-20200323-175228/nlu"
# model = "./NLU/models/20200323-181158/nlu"


# #model = "./NLU/models/20200310-190259/nlu"

# # loading the model from one directory or zip file
# #interpreter = Interpreter.load(model)

# #------------------FACT- NLG ----------------------------------------------------------

# #MONGODB_URL= "mongodb://0.tcp.ngrok.io:11014/?compressors=disabled&gssapiServiceName=mongodb"
# #MONGODB_URL= "mongodb://0.tcp.ngrok.io:14723/?compressors=disabled&gssapiServiceName=mongodb"
# #MONGODB_URL= "mongodb://0.tcp.ngrok.io:16626/?compressors=disabled&gssapiServiceName=mongodb"
# #MONGODB_URL= "mongodb://0.tcp.ngrok.io:16206/?compressors=disabled&gssapiServiceName=mongodb"
# MONGODB_URL= "mongodb://f21ca:watt6789@18.219.152.221:27017/shome"

# MODEL_ADDR = model

# #---------------------------------------------------------------------------------
# class EcoBot(Bot):
#     def __init__(self, **kwargs):
#         # Warning: the init method will be called every time before the post() method
#         # Don't use it to initialise or load files.
#         # We will use kwargs to specify already initialised objects that are required to the bot
#         super(EcoBot, self).__init__(bot_name=BOT_NAME)
#         self.facts = [
#             "Fact 1",
#             "Fact 2",
#             "Fact 3"
#         ]

#     def get(self):
#         pass

#     def post(self):
#         # This method will be executed for every POST request received by the server on the
#         # "/" endpoint (see below 'add_resource')

#         # We assume that the body of the incoming request is formatted as JSON (i.e., its Content-Type is JSON)
#         # We parse the JSON content and we obtain a dictionary object
#         request_data = request.get_json(force=True)

#         # We wrap the resulting dictionary in a custom object that allows data access via dot-notation
#         request_data = DictQuery(request_data)

#         # We extract several information from the state
#         user_utterance = request_data.get("current_state.state.nlu.annotations.processed_text")
#         last_bot = request_data.get("current_state.state.last_bot")
#         question = request_data["question"]

#         logger.info("------- Turn info ----------")
#         logger.info("User utterance: {}".format(user_utterance))
#         logger.info("Last bot: {}".format(last_bot))
#         logger.info("---------------------------")

#         #-----------BOT OUTPUT------------------------------
        
#         # the 'result' member is intended as the actual response of the bot   
#         #self.response.result =user_utterance # random.choice(self.facts)
#         # parsing the utterance
        
#                 #interpretation = interpreter.parse(user_utterance)
#                 #self.response.result = interpretation['intent']['name']

	
#         #alp = ActionLanguageProcessor(mongodb_url=MONGODB_URL, model_file=MODEL_ADDR)
#         alp = ActionLanguageProcessor(mongodb_url=MONGODB_URL,model_file=MODEL_ADDR)
#         self.response.result = alp.analyse_utterance(question)
#         # print(self.response.result)
        
#         #---------------------------------------------------
        
        
        
        
#         # we store in the dictionary 'bot_params' the current time. Remember that this information will be stored
#         # in the database only if the bot is selected
#         self.response.bot_params["time"] = str(datetime.now())

#         # The response generated by the bot is always considered as a list (we allow a bot to generate multiple response
#         # objects for the same turn). Here we create a singleton list with the response in JSON format
#         return [self.response.toJSON()]


# if __name__ == "__main__":
#     args = parser.parse_args()
    
#     if not os.path.exists("logs/"):
#         os.makedirs("logs/")

#     log.set_logger_params(BOT_NAME + '-' + BRANCH, logfile=args.logfile,
#                           file_level=args.file_verbosity, console_level=args.console_verbosity)

#     api.add_resource(EcoBot, "/")

#     app.run(host="0.0.0.0", port=args.port)


import logging
import random
from argparse import ArgumentParser

import os
from flask import Flask, request
from flask_restful import Api
from utils import log
from utils.abstract_classes import Bot
from utils.dict_query import DictQuery
from datetime import datetime
import random

from ALP import ActionLanguageProcessor

app = Flask(__name__)
api = Api(app)
BOT_NAME = "EcoBot"
VERSION = log.get_short_git_version()
BRANCH = log.get_git_branch()

logger = logging.getLogger(__name__)

parser = ArgumentParser()
parser.add_argument('-p', "--port", type=int, default=5130)
parser.add_argument('-l', '--logfile', type=str, default='logs/' + BOT_NAME + '.log')
parser.add_argument('-cv', '--console-verbosity', default='info', help='Console logging verbosity')
parser.add_argument('-fv', '--file-verbosity', default='debug', help='File logging verbosity')

MONGODB_URL= "mongodb://f21ca:watt6789@18.219.152.221:27017/shome"

class EcoBot(Bot):
    def __init__(self, **kwargs):
        # Warning: the init method will be called every time before the post() method
        # Don't use it to initialise or load files.
        # We will use kwargs to specify already initialised objects that are required to the bot
        super(EcoBot, self).__init__(bot_name=BOT_NAME)
        self.EcoBot = [
            "Ciao",
            "Hello",
            "Hola"
        ]

    def get(self):
        pass

    def post(self):
        # This method will be executed for every POST request received by the server on the
        # "/" endpoint (see below 'add_resource')

        # We assume that the body of the incoming request is formatted as JSON (i.e., its Content-Type is JSON)
        # We parse the JSON content and we obtain a dictionary object
        request_data = request.get_json(force=True)

        # We wrap the resulting dictionary in a custom object that allows data access via dot-notation
        request_data = DictQuery(request_data)

        # We extract several information from the state
        user_utterance = request_data.get("current_state.state.nlu.annotations.processed_text")
        last_bot = request_data.get("current_state.state.last_bot")
        # print(request_data)
        # question = request_data["question"]

        logger.info("------- Turn info ----------")
        logger.info("User utterance: {}".format(user_utterance))
        logger.info("Last bot: {}".format(last_bot))
        logger.info("---------------------------")

        #-----------BOT OUTPUT------------------------------

        alp = ActionLanguageProcessor(mongodb_url=MONGODB_URL,model_file=None)
        self.response.result = alp.analyse_utterance(user_utterance)
        # print(self.response.result)

        # the 'result' member is intended as the actual response of the bot
        # self.response.result = random.choice(self.greetings)
        # print(self.response.result)
        # we store in the dictionary 'bot_params' the current time. Remember that this information will be stored
        # in the database only if the bot is selected
        self.response.bot_params["time"] = str(datetime.now())

        # The response generated by the bot is always considered as a list (we allow a bot to generate multiple response
        # objects for the same turn). Here we create a singleton list with the response in JSON format
        return [self.response.toJSON()]


if __name__ == "__main__":
    args = parser.parse_args()
    
    if not os.path.exists("logs/"):
        os.makedirs("logs/")

    log.set_logger_params(BOT_NAME + '-' + BRANCH, logfile=args.logfile,
                          file_level=args.file_verbosity, console_level=args.console_verbosity)

    api.add_resource(EcoBot, "/")

    app.run(host="0.0.0.0", port=args.port)